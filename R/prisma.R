#' Extract PRISMA 2020-Compatible Counts from Download Log
#'
#' Maps paperfetch download log data to PRISMA 2020 flow diagram categories,
#' specifically for the "Full-Text Retrieval" phase. Works seamlessly with
#' the \code{PRISMA2020} R package.
#'
#' @param log_file Path to the download log CSV generated by paperfetch,
#'   OR a data frame already loaded into R
#' @param verbose Print a formatted summary of counts (default: TRUE)
#'
#' @return A named list with PRISMA 2020 counts:
#'   \itemize{
#'     \item \code{reports_sought_retrieval} — Total records sent for retrieval
#'     \item \code{reports_not_retrieved}    — Records where no PDF was found
#'     \item \code{reports_excluded_invalid} — PDFs downloaded but failed integrity check
#'     \item \code{reports_acquired}         — Valid PDFs successfully retrieved
#'     \item \code{reports_skipped}          — Already existed, not re-downloaded
#'   }
#'
#' @details
#' Maps to PRISMA 2020 Section 3 (Identification) as follows:
#'
#' \tabular{ll}{
#'   \strong{PRISMA 2020 field} \tab \strong{paperfetch source} \cr
#'   Reports sought for retrieval  \tab All rows in log (excl. skipped) \cr
#'   Reports not retrieved         \tab \code{success == FALSE} \cr
#'   Reports excluded (invalid)    \tab \code{pdf_valid == FALSE} \cr
#'   Reports acquired              \tab \code{success == TRUE & pdf_valid == TRUE} \cr
#' }
#'
#' @export
#'
#' @examples
#' \dontrun{
#' # After fetching PDFs
#' fetch_pdfs("dois.csv", email = "you@edu", log_file = "download_log.csv")
#'
#' # Extract PRISMA counts
#' prisma_stats <- as_prisma_counts("download_log.csv")
#'
#' # Use with PRISMA2020 package
#' if (requireNamespace("PRISMA2020", quietly = TRUE)) {
#'   plot_prisma_fulltext(prisma_stats)
#' }
#' }

as_prisma_counts <- function(log_file, verbose = TRUE) {
  
  # Accept either a file path or an already-loaded data frame
  if (is.character(log_file)) {
    if (!file.exists(log_file)) {
      cli_abort(c(
        "Log file not found: {.file {log_file}}",
        "i" = "Run {.fn fetch_pdfs} with a {.arg log_file} argument first."
      ))
    }
    log_data <- read_csv(log_file, show_col_types = FALSE)
  } else if (is.data.frame(log_file)) {
    log_data <- log_file
  } else {
    cli_abort("{.arg log_file} must be a file path or a data frame.")
  }
  
  # Validate expected columns
  required_cols <- c("success", "status")
  missing_cols  <- required_cols[!required_cols %in% colnames(log_data)]
  if (length(missing_cols) > 0) {
    cli_abort(c(
      "Log file is missing required columns: {.field {missing_cols}}",
      "i" = "Ensure the log was generated by {.pkg paperfetch} v0.1.0 or later."
    ))
  }
  
  # Separate skipped (already existed) from active attempts
  skipped      <- log_data[!is.na(log_data$status) & log_data$status == "exists", ]
  active       <- log_data[is.na(log_data$status)  | log_data$status != "exists", ]
  
  # Core PRISMA counts
  n_sought        <- nrow(active)
  n_not_retrieved <- sum(active$success == FALSE, na.rm = TRUE)
  
  # Invalid PDFs — only counted if validation was run
  n_invalid <- if ("pdf_valid" %in% colnames(active)) {
    sum(active$pdf_valid == FALSE, na.rm = TRUE)
  } else {
    NA_integer_
  }
  
  # Successfully acquired = downloaded AND passed validation
  n_acquired <- if ("pdf_valid" %in% colnames(active)) {
    sum(active$success == TRUE & active$pdf_valid == TRUE, na.rm = TRUE)
  } else {
    sum(active$success == TRUE, na.rm = TRUE)
  }
  
  n_skipped <- nrow(skipped)
  
  # Method breakdown for detail
  method_counts <- if ("method" %in% colnames(active)) {
    active_success <- active[active$success == TRUE, ]
    as.list(table(active_success$method))
  } else {
    NULL
  }
  
  # Failure reason breakdown
  failure_counts <- if ("failure_reason" %in% colnames(active)) {
    active_failed <- active[active$success == FALSE & !is.na(active$failure_reason), ]
    as.list(table(active_failed$failure_reason))
  } else {
    NULL
  }
  
  # Build result list
  counts <- list(
    reports_sought_retrieval = n_sought,
    reports_not_retrieved    = n_not_retrieved,
    reports_excluded_invalid = if (!is.na(n_invalid)) n_invalid else 0L,
    reports_acquired         = n_acquired,
    reports_skipped          = n_skipped,
    method_breakdown         = method_counts,
    failure_breakdown        = failure_counts
  )
  
  # ── Print summary ─────────────────────────────────────────────────────────────
  
  if (verbose) {
    cli_rule(left = "PRISMA 2020 Full-Text Retrieval Counts")
    cli_bullets(c(
      " " = "Reports sought for retrieval: {.strong {n_sought}}",
      " " = "Reports not retrieved:        {.strong {n_not_retrieved}}",
      " " = "Reports excluded (invalid PDF):{.strong {if (!is.na(n_invalid)) n_invalid else 'not validated'}}",
      " " = "Reports acquired:              {.strong {n_acquired}}"
    ))
    
    if (n_skipped > 0) {
      cli_alert_info(
        "{n_skipped} record{?s} skipped (already downloaded from previous session)"
      )
    }
    
    if (!is.null(method_counts) && length(method_counts) > 0) {
      cli_rule(left = "Acquisition method breakdown")
      for (method in names(method_counts)) {
        cli_bullets(c(" " = "{method}: {method_counts[[method]]}"))
      }
    }
    
    if (!is.null(failure_counts) && length(failure_counts) > 0) {
      cli_rule(left = "Failure reason breakdown")
      for (reason in names(failure_counts)) {
        cli_bullets(c(" " = "{reason}: {failure_counts[[reason]]}"))
      }
    }
    
    cli_rule()
    cli_alert_info(
      "Use {.fn plot_prisma_fulltext} to generate a PRISMA 2020 flow diagram."
    )
  }
  
  return(counts)
}


#' Normalize PRISMA Structure
#'
#' Internal helper to fix multi-row data frames that break PRISMA_flowdiagram().
#' Collapses data frames with "reason" and "n" columns into single-row format
#' with newline-separated values. Handles NULL, empty, and multi-row cases.
#'
#' @param x A list element from PRISMA_data() output
#' @return The normalized element (single-row data frame or unchanged)
#' @noRd
normalize_prisma_structure <- function(x) {
  if (is.data.frame(x) && all(c("reason", "n") %in% names(x))) {
    
    # Handle NULL or empty reason
    if (is.null(x$reason) || length(x$reason) == 0) {
      x$reason <- ""
    }
    
    # Handle NULL or empty n
    if (is.null(x$n) || length(x$n) == 0) {
      x$n <- ""
    }
    
    # Ensure at least one row
    if (nrow(x) == 0) {
      x <- data.frame(
        reason = "",
        n = "",
        stringsAsFactors = FALSE
      )
    }
    
    # **KEY FIX**: Collapse multiple rows into single row with newlines
    # This prevents str_count() from returning length > 1 vectors that break
    # the condition in PRISMA_get_height_()
    if (nrow(x) > 1) {
      x <- data.frame(
        reason = paste(x$reason, collapse = "\n"),
        n = paste(x$n, collapse = "\n"),
        stringsAsFactors = FALSE
      )
    }
  }
  x
}


#' Generate PRISMA 2020 Full-Text Retrieval Flow Diagram
#'
#' Uses the \code{PRISMA2020} package to generate the full-text retrieval
#' section of a PRISMA 2020 flow diagram, pre-filled with counts from
#' your \code{as_prisma_counts()} output.
#'
#' @param prisma_counts Named list from \code{as_prisma_counts()}
#' @param previous_counts Optional named list of counts from earlier PRISMA
#'   phases (identification, screening). See Details.
#' @param save_path Optional file path to save the diagram (e.g.,
#'   \code{"prisma_diagram.png"}). NULL prints to screen (default: NULL)
#' @param interactive Return an interactive diagram (default: FALSE)
#'
#' @return A PRISMA 2020 flow diagram object (invisibly)
#'
#' @details
#' Requires the \code{PRISMA2020} package. Install with:
#' \code{install.packages("PRISMA2020")}
#'
#' The \code{previous_counts} argument accepts a named list for earlier
#' PRISMA phases. Supported names:
#' \itemize{
#'   \item \code{database_results} — Records from database searches
#'   \item \code{register_results} — Records from registers
#'   \item \code{duplicates_removed} — Records removed as duplicates
#'   \item \code{records_screened} — Records screened (title/abstract)
#'   \item \code{records_excluded} — Records excluded at screening
#' }
#'
#' @importFrom utils read.csv
#' @export
#'
#' @examples
#' \dontrun{
#' prisma_counts <- as_prisma_counts("download_log.csv")
#'
#' # Simple: full-text section only
#' plot_prisma_fulltext(prisma_counts)
#'
#' # Full diagram with earlier phases
#' plot_prisma_fulltext(
#'   prisma_counts,
#'   previous_counts = list(
#'     database_results   = 892,
#'     duplicates_removed = 238,
#'     records_screened   = 654,
#'     records_excluded   = 126
#'   ),
#'   save_path = "figures/prisma_diagram.png"
#' )
#' }

plot_prisma_fulltext <- function(prisma_counts,
                                 previous_counts = NULL,
                                 save_path       = NULL,
                                 interactive     = FALSE) {
  
  # Check PRISMA2020 is available
  if (!requireNamespace("PRISMA2020", quietly = TRUE)) {
    cli_abort(c(
      "Package {.pkg PRISMA2020} is required for flow diagrams.",
      "i" = "Install it with: {.code install.packages(\"PRISMA2020\")}",
      "i" = "Or from GitHub: {.code devtools::install_github(\"MatthewBJane/PRISMA2020\")}"
    ))
  }
  
  # **CRITICAL FIX**: Patch PRISMA_get_height_ to handle vector inputs
  # This prevents "condition has length > 1" errors that occur when
  # PRISMA2020 internal code creates label vectors from data frames
  utils::assignInNamespace(
    "PRISMA_get_height_",
    function(n, offset, min = 2) {
      lines <- max(n) + 1  # Handle vector inputs by taking max
      if (lines > min) {
        height <- offset + (lines * 0.25) - (min * 0.25)
      } else {
        height <- offset
      }
      return(height)
    },
    ns = "PRISMA2020"
  )
  
  # ── Build the data frame that PRISMA_data() expects ──────────────────────────
  #
  # PRISMA_data() requires the full template data frame (all 8 columns, 32 rows)
  # that ships with the package. We load it, then overwrite only the `n` values
  # for the rows we care about. This is version-safe because we never construct
  # the data frame from scratch.
  
  csv_path <- system.file("extdata", "PRISMA.csv", package = "PRISMA2020")
  if (!nzchar(csv_path)) {
    cli_abort("Could not find PRISMA.csv inside the PRISMA2020 package installation.")
  }
  prisma_df <- utils::read.csv(csv_path, stringsAsFactors = FALSE)
  
  # Helper to set n for a named row (matched on the `data` column)
  set_n <- function(df, row_name, value) {
    idx <- which(df$data == row_name)
    if (length(idx) > 0 && !is.null(value) && !is.na(value)) {
      df$n[idx] <- as.character(value)
    }
    df
  }
  
  # ── Identification phase (from previous_counts if supplied) ──────────────────
  prisma_df <- set_n(prisma_df, "database_results",  previous_counts$database_results  %||% NULL)
  prisma_df <- set_n(prisma_df, "register_results",  previous_counts$register_results  %||% NULL)
  prisma_df <- set_n(prisma_df, "duplicates",        previous_counts$duplicates_removed %||% NULL)
  
  # ── Screening phase ───────────────────────────────────────────────────────────
  prisma_df <- set_n(prisma_df, "records_screened",  previous_counts$records_screened  %||% NULL)
  prisma_df <- set_n(prisma_df, "records_excluded",  previous_counts$records_excluded  %||% NULL)
  
  # Full-text retrieval phase (filled by paperfetch)
  prisma_df <- set_n(prisma_df, "dbr_sought_reports",       prisma_counts$reports_sought_retrieval)
  prisma_df <- set_n(prisma_df, "dbr_notretrieved_reports", prisma_counts$reports_not_retrieved)
  prisma_df <- set_n(prisma_df, "dbr_assessed",             prisma_counts$reports_acquired)
  
  # Inclusion phase
  prisma_df <- set_n(prisma_df, "new_studies", prisma_counts$reports_acquired)
  
  # Parse through PRISMA_data() exactly as the official example:
  #   data <- read.csv(csvFile); data <- PRISMA_data(data); PRISMA_flowdiagram(data)
  prisma_template <- PRISMA2020::PRISMA_data(prisma_df)
  
  # Apply normalization to ALL data frames in the template to prevent
  # "argument is of length > 1" errors in PRISMA_get_height_()
  prisma_template <- lapply(prisma_template, normalize_prisma_structure)
  
  # Fix multi-row data frames AFTER PRISMA_data() runs.
  # PRISMA_data() populates these as 3-row data frames with placeholder reasons.
  # PRISMA_flowdiagram() pastes all rows into a label string and calls
  # stringr::str_count(label, "\n") — returning a length-3 vector, crashing
  # PRISMA_get_height_() with "argument is of length > 1".
  # Fix: collapse ALL multi-row data frames to exactly ONE row.
  n_excluded <- prisma_counts$reports_excluded_invalid %||% 0L
  
  prisma_template$dbr_excluded <- if (n_excluded == 0) {
    data.frame(reason = "None", n = "0", stringsAsFactors = FALSE)
  } else {
    data.frame(
      reason = "Invalid PDF (failed integrity check)",
      n      = as.character(n_excluded),
      stringsAsFactors = FALSE
    )
  }
  
  prisma_template$other_excluded <- data.frame(
    reason = "None", n = "0", stringsAsFactors = FALSE
  )
  
  prisma_template$database_specific_results <- data.frame(
    reason = "All databases",
    n      = as.character(prisma_counts$reports_sought_retrieval),
    stringsAsFactors = FALSE
  )
  
  prisma_template$register_specific_results <- data.frame(
    reason = "None", n = "0", stringsAsFactors = FALSE
  )
  
  # Generate the flow diagram
  diagram <- PRISMA2020::PRISMA_flowdiagram(
    data        = prisma_template,
    interactive = interactive,
    previous    = !is.null(previous_counts),
    other       = FALSE
  )
  
  # Save if requested
  if (!is.null(save_path)) {
    # Create parent directory if it doesn't exist
    save_dir <- dirname(save_path)
    if (!dir.exists(save_dir)) {
      dir.create(save_dir, recursive = TRUE)
    }
    
    ext <- tolower(tools::file_ext(save_path))
    
    if (ext == "png") {
      grDevices::png(save_path, width = 800, height = 1000, res = 150)
      print(diagram)
      grDevices::dev.off()
    } else if (ext == "pdf") {
      grDevices::pdf(save_path, width = 8, height = 10)
      print(diagram)
      grDevices::dev.off()
    } else if (ext == "svg") {
      grDevices::svg(save_path, width = 8, height = 10)
      print(diagram)
      grDevices::dev.off()
    } else {
      cli_alert_warning(
        "Unsupported format {.val {ext}}. Use .png, .pdf, or .svg"
      )
    }
    
    cli_alert_success("PRISMA diagram saved to {.file {save_path}}")
  }
  
  invisible(diagram)
}


# Null-coalescing operator (internal only, no export)
`%||%` <- function(x, y) if (!is.null(x)) x else y