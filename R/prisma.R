#' Extract PRISMA 2020-Compatible Counts from Download Log
#'
#' Maps paperfetch download log data to PRISMA 2020 flow diagram categories,
#' specifically for the "Full-Text Retrieval" phase. Works seamlessly with
#' the \code{PRISMA2020} R package.
#'
#' @param log_file Path to the download log CSV generated by paperfetch,
#'   OR a data frame already loaded into R
#' @param verbose Print a formatted summary of counts (default: TRUE)
#'
#' @return A named list with PRISMA 2020 counts:
#'   \itemize{
#'     \item \code{reports_sought_retrieval} — Total records sent for retrieval
#'     \item \code{reports_not_retrieved}    — Records where no PDF was found
#'     \item \code{reports_excluded_invalid} — PDFs downloaded but failed integrity check
#'     \item \code{reports_acquired}         — Valid PDFs successfully retrieved
#'     \item \code{reports_skipped}          — Already existed, not re-downloaded
#'   }
#'
#' @details
#' Maps to PRISMA 2020 Section 3 (Identification) as follows:
#'
#' \tabular{ll}{
#'   \strong{PRISMA 2020 field} \tab \strong{paperfetch source} \cr
#'   Reports sought for retrieval  \tab All rows in log (excl. skipped) \cr
#'   Reports not retrieved         \tab \code{success == FALSE} \cr
#'   Reports excluded (invalid)    \tab \code{pdf_valid == FALSE} \cr
#'   Reports acquired              \tab \code{success == TRUE & pdf_valid == TRUE} \cr
#' }
#'
#' @export
#'
#' @examples
#' \dontrun{
#' # After fetching PDFs
#' fetch_pdfs("dois.csv", email = "you@edu", log_file = "download_log.csv")
#'
#' # Extract PRISMA counts
#' prisma_stats <- as_prisma_counts("download_log.csv")
#'
#' # Use with PRISMA2020 package
#' if (requireNamespace("PRISMA2020", quietly = TRUE)) {
#'   plot_prisma_fulltext(prisma_stats)
#' }
#' }

as_prisma_counts <- function(log_file, verbose = TRUE) {
  require(cli)
  require(readr)
  
  # Accept either a file path or an already-loaded data frame
  if (is.character(log_file)) {
    if (!file.exists(log_file)) {
      cli_abort(c(
        "Log file not found: {.file {log_file}}",
        "i" = "Run {.fn fetch_pdfs} with a {.arg log_file} argument first."
      ))
    }
    log_data <- read_csv(log_file, show_col_types = FALSE)
  } else if (is.data.frame(log_file)) {
    log_data <- log_file
  } else {
    cli_abort("{.arg log_file} must be a file path or a data frame.")
  }
  
  # Validate expected columns
  required_cols <- c("success", "status")
  missing_cols  <- required_cols[!required_cols %in% colnames(log_data)]
  if (length(missing_cols) > 0) {
    cli_abort(c(
      "Log file is missing required columns: {.field {missing_cols}}",
      "i" = "Ensure the log was generated by {.pkg paperfetch} v0.1.0 or later."
    ))
  }
  
  # Separate skipped (already existed) from active attempts
  skipped      <- log_data[!is.na(log_data$status) & log_data$status == "exists", ]
  active       <- log_data[is.na(log_data$status)  | log_data$status != "exists", ]
  
  # Core PRISMA counts
  n_sought     <- nrow(active)
  n_not_retrieved <- sum(active$success == FALSE, na.rm = TRUE)
  
  # Invalid PDFs — only counted if validation was run
  n_invalid <- if ("pdf_valid" %in% colnames(active)) {
    sum(active$pdf_valid == FALSE, na.rm = TRUE)
  } else {
    NA_integer_
  }
  
  # Successfully acquired = downloaded AND passed validation
  n_acquired <- if ("pdf_valid" %in% colnames(active)) {
    sum(active$success == TRUE & active$pdf_valid == TRUE, na.rm = TRUE)
  } else {
    sum(active$success == TRUE, na.rm = TRUE)
  }
  
  n_skipped <- nrow(skipped)
  
  # Method breakdown for detail
  method_counts <- if ("method" %in% colnames(active)) {
    active_success <- active[active$success == TRUE, ]
    as.list(table(active_success$method))
  } else {
    NULL
  }
  
  # Failure reason breakdown
  failure_counts <- if ("failure_reason" %in% colnames(active)) {
    active_failed <- active[active$success == FALSE & !is.na(active$failure_reason), ]
    as.list(table(active_failed$failure_reason))
  } else {
    NULL
  }
  
  # Build result list
  counts <- list(
    reports_sought_retrieval = n_sought,
    reports_not_retrieved    = n_not_retrieved,
    reports_excluded_invalid = if (!is.na(n_invalid)) n_invalid else 0L,
    reports_acquired         = n_acquired,
    reports_skipped          = n_skipped,
    method_breakdown         = method_counts,
    failure_breakdown        = failure_counts
  )
  
  # ── Print summary ─────────────────────────────────────────────────────────────
  
  if (verbose) {
    cli_rule(left = "PRISMA 2020 Full-Text Retrieval Counts")
    cli_bullets(c(
      " " = "Reports sought for retrieval: {.strong {n_sought}}",
      " " = "Reports not retrieved:        {.strong {n_not_retrieved}}",
      " " = "Reports excluded (invalid PDF):{.strong {if (!is.na(n_invalid)) n_invalid else 'not validated'}}",
      " " = "Reports acquired:              {.strong {n_acquired}}"
    ))
    
    if (n_skipped > 0) {
      cli_alert_info(
        "{n_skipped} record{?s} skipped (already downloaded from previous session)"
      )
    }
    
    if (!is.null(method_counts) && length(method_counts) > 0) {
      cli_rule(left = "Acquisition method breakdown")
      for (method in names(method_counts)) {
        cli_bullets(c(" " = "{method}: {method_counts[[method]]}"))
      }
    }
    
    if (!is.null(failure_counts) && length(failure_counts) > 0) {
      cli_rule(left = "Failure reason breakdown")
      for (reason in names(failure_counts)) {
        cli_bullets(c(" " = "{reason}: {failure_counts[[reason]]}"))
      }
    }
    
    cli_rule()
    cli_alert_info(
      "Use {.fn plot_prisma_fulltext} to generate a PRISMA 2020 flow diagram."
    )
  }
  
  return(counts)
}


#' Generate PRISMA 2020 Full-Text Retrieval Flow Diagram
#'
#' Uses the \code{PRISMA2020} package to generate the full-text retrieval
#' section of a PRISMA 2020 flow diagram, pre-filled with counts from
#' your \code{as_prisma_counts()} output.
#'
#' @param prisma_counts Named list from \code{as_prisma_counts()}
#' @param previous_counts Optional named list of counts from earlier PRISMA
#'   phases (identification, screening). See Details.
#' @param save_path Optional file path to save the diagram (e.g.,
#'   \code{"prisma_diagram.png"}). NULL prints to screen (default: NULL)
#' @param interactive Return an interactive diagram (default: FALSE)
#'
#' @return A PRISMA 2020 flow diagram object (invisibly)
#'
#' @details
#' The \code{previous_counts} argument accepts a named list for earlier
#' PRISMA phases. Supported names:
#' \itemize{
#'   \item \code{database_results} — Records from database searches
#'   \item \code{register_results} — Records from registers
#'   \item \code{duplicates_removed} — Records removed as duplicates
#'   \item \code{records_screened} — Records screened (title/abstract)
#'   \item \code{records_excluded} — Records excluded at screening
#' }
#'
#' @export
#'
#' @examples
#' \dontrun{
#' prisma_counts <- as_prisma_counts("download_log.csv")
#'
#' # Simple: full-text section only
#' plot_prisma_fulltext(prisma_counts)
#'
#' # Full diagram with earlier phases
#' plot_prisma_fulltext(
#'   prisma_counts,
#'   previous_counts = list(
#'     database_results  = 892,
#'     duplicates_removed = 238,
#'     records_screened  = 654,
#'     records_excluded  = 126
#'   ),
#'   save_path = "figures/prisma_diagram.png"
#' )
#' }

plot_prisma_fulltext <- function(prisma_counts,
                                 previous_counts = NULL,
                                 save_path       = NULL,
                                 interactive     = FALSE) {
  
  require(cli)
  
  # Check PRISMA2020 is available
  if (!requireNamespace("PRISMA2020", quietly = TRUE)) {
    cli_abort(c(
      "Package {.pkg PRISMA2020} is required for flow diagrams.",
      "i" = "Install it with: {.code install.packages(\"PRISMA2020\")}",
      "i" = "Or from GitHub: {.code devtools::install_github(\"MatthewBJane/PRISMA2020\")}"
    ))
  }
  
  # Build PRISMA data template
  prisma_template <- PRISMA2020::PRISMA_data(
    
    # ── Identification phase ──────────────────────────────────────────────────
    database_results   = previous_counts$database_results  %||% NA,
    register_results   = previous_counts$register_results  %||% NA,
    
    # ── Screening phase ───────────────────────────────────────────────────────
    duplicates         = previous_counts$duplicates_removed %||% NA,
    records_screened   = previous_counts$records_screened   %||% NA,
    records_excluded   = previous_counts$records_excluded   %||% NA,
    
    # ── Full-text retrieval phase (filled by paperfetch) ─────────────────────
    dbr_sought_reports = prisma_counts$reports_sought_retrieval,
    dbr_notretrieved   = prisma_counts$reports_not_retrieved,
    
    # ── Inclusion phase ───────────────────────────────────────────────────────
    dbr_assessed       = prisma_counts$reports_acquired,
    dbr_excluded       = prisma_counts$reports_excluded_invalid %||% 0
  )
  
  # Generate the flow diagram
  diagram <- PRISMA2020::PRISMA_flowchart(
    data        = prisma_template,
    interactive = interactive
  )
  
  # Save if requested
  if (!is.null(save_path)) {
    ext <- tolower(tools::file_ext(save_path))
    
    if (ext == "png") {
      grDevices::png(save_path, width = 800, height = 1000, res = 150)
      print(diagram)
      grDevices::dev.off()
    } else if (ext == "pdf") {
      grDevices::pdf(save_path, width = 8, height = 10)
      print(diagram)
      grDevices::dev.off()
    } else if (ext == "svg") {
      grDevices::svg(save_path, width = 8, height = 10)
      print(diagram)
      grDevices::dev.off()
    } else {
      cli_alert_warning(
        "Unsupported format {.val {ext}}. Use .png, .pdf, or .svg"
      )
    }
    
    cli_alert_success("PRISMA diagram saved to {.file {save_path}}")
  }
  
  invisible(diagram)
}


#' Null-coalescing operator
#' @keywords internal
`%||%` <- function(x, y) if (!is.null(x)) x else y